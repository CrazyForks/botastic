// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"
	"strings"

	"gorm.io/gorm"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"github.com/pandodao/botastic/core"
)

func newIndex(db *gorm.DB, opts ...gen.DOOption) index {
	_index := index{}

	_index.indexDo.UseDB(db, opts...)
	_index.indexDo.UseModel(&core.Index{})

	tableName := _index.indexDo.TableName()
	_index.ALL = field.NewAsterisk(tableName)
	_index.ID = field.NewUint64(tableName, "id")
	_index.AppID = field.NewUint64(tableName, "app_id")
	_index.Data = field.NewString(tableName, "data")
	_index.Vectors = field.NewField(tableName, "vectors")
	_index.ObjectID = field.NewString(tableName, "object_id")
	_index.IndexName = field.NewString(tableName, "index_name")
	_index.Category = field.NewString(tableName, "category")
	_index.Properties = field.NewString(tableName, "properties")
	_index.CreatedAt = field.NewTime(tableName, "created_at")
	_index.UpdatedAt = field.NewTime(tableName, "updated_at")
	_index.DeletedAt = field.NewTime(tableName, "deleted_at")

	_index.fillFieldMap()

	return _index
}

type index struct {
	indexDo

	ALL        field.Asterisk
	ID         field.Uint64
	AppID      field.Uint64
	Data       field.String
	Vectors    field.Field
	ObjectID   field.String
	IndexName  field.String
	Category   field.String
	Properties field.String
	CreatedAt  field.Time
	UpdatedAt  field.Time
	DeletedAt  field.Time

	fieldMap map[string]field.Expr
}

func (i index) Table(newTableName string) *index {
	i.indexDo.UseTable(newTableName)
	return i.updateTableName(newTableName)
}

func (i index) As(alias string) *index {
	i.indexDo.DO = *(i.indexDo.As(alias).(*gen.DO))
	return i.updateTableName(alias)
}

func (i *index) updateTableName(table string) *index {
	i.ALL = field.NewAsterisk(table)
	i.ID = field.NewUint64(table, "id")
	i.AppID = field.NewUint64(table, "app_id")
	i.Data = field.NewString(table, "data")
	i.Vectors = field.NewField(table, "vectors")
	i.ObjectID = field.NewString(table, "object_id")
	i.IndexName = field.NewString(table, "index_name")
	i.Category = field.NewString(table, "category")
	i.Properties = field.NewString(table, "properties")
	i.CreatedAt = field.NewTime(table, "created_at")
	i.UpdatedAt = field.NewTime(table, "updated_at")
	i.DeletedAt = field.NewTime(table, "deleted_at")

	i.fillFieldMap()

	return i
}

func (i *index) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := i.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (i *index) fillFieldMap() {
	i.fieldMap = make(map[string]field.Expr, 11)
	i.fieldMap["id"] = i.ID
	i.fieldMap["app_id"] = i.AppID
	i.fieldMap["data"] = i.Data
	i.fieldMap["vectors"] = i.Vectors
	i.fieldMap["object_id"] = i.ObjectID
	i.fieldMap["index_name"] = i.IndexName
	i.fieldMap["category"] = i.Category
	i.fieldMap["properties"] = i.Properties
	i.fieldMap["created_at"] = i.CreatedAt
	i.fieldMap["updated_at"] = i.UpdatedAt
	i.fieldMap["deleted_at"] = i.DeletedAt
}

func (i index) clone(db *gorm.DB) index {
	i.indexDo.ReplaceConnPool(db.Statement.ConnPool)
	return i
}

func (i index) replaceDB(db *gorm.DB) index {
	i.indexDo.ReplaceDB(db)
	return i
}

type indexDo struct{ gen.DO }

type IIndexDo interface {
	WithContext(ctx context.Context) IIndexDo

	UpsertIndex(ctx context.Context, idx *core.Index) (err error)
	GetIndexes(ctx context.Context) (result []*core.Index, err error)
}

// INSERT INTO @@table
//
//	("app_id", "data", "vectors", "object_id", "index_name", "category", "properties", "created_at", "updated_at")
//
// VALUES
//
//	(@idx.AppID, @idx.Data, @idx.Vectors, @idx.ObjectID, @idx.IndexName, @idx.Category, @idx.Properties, NOW(), NOW())
//
// ON CONFLICT ("app_id", "object_id") DO
//
//	UPDATE SET "data" = @idx.Data, "vectors" = @idx.Vectors, "index_name" = @idx.IndexName, "category" = @idx.Category, "properties" = @idx.Properties, "updated_at" = NOW()
func (i indexDo) UpsertIndex(ctx context.Context, idx *core.Index) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, idx.AppID)
	params = append(params, idx.Data)
	params = append(params, idx.Vectors)
	params = append(params, idx.ObjectID)
	params = append(params, idx.IndexName)
	params = append(params, idx.Category)
	params = append(params, idx.Properties)
	params = append(params, idx.Data)
	params = append(params, idx.Vectors)
	params = append(params, idx.IndexName)
	params = append(params, idx.Category)
	params = append(params, idx.Properties)
	generateSQL.WriteString("INSERT INTO indexes (\"app_id\", \"data\", \"vectors\", \"object_id\", \"index_name\", \"category\", \"properties\", \"created_at\", \"updated_at\") VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW()) ON CONFLICT (\"app_id\", \"object_id\") DO UPDATE SET \"data\" = ?, \"vectors\" = ?, \"index_name\" = ?, \"category\" = ?, \"properties\" = ?, \"updated_at\" = NOW() ")

	var executeSQL *gorm.DB
	executeSQL = i.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT * FROM @@table WHERE
//
//	"deleted_at" IS NULL
func (i indexDo) GetIndexes(ctx context.Context) (result []*core.Index, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("SELECT * FROM indexes WHERE \"deleted_at\" IS NULL ")

	var executeSQL *gorm.DB
	executeSQL = i.UnderlyingDB().Raw(generateSQL.String()).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (i indexDo) WithContext(ctx context.Context) IIndexDo {
	return i.withDO(i.DO.WithContext(ctx))
}

func (i *indexDo) withDO(do gen.Dao) *indexDo {
	i.DO = *do.(*gen.DO)
	return i
}
